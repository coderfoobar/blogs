
# Java - 线程重入

> Create Time : 2017年4月18日 

* 当程序的正确性取决于多个线程交替执行的顺序时，就会发生`竞态条件`。
* 导致`竞态条件`发生的代码区域称之为`临界区`。
* 在`临界区`上`加锁`，可以保证竞态条件不再发生。

`synchronized`是Java中的一种内置锁。可以修饰在方法签名上，也可以通过同步代码块的形式加锁。

`synchronized`的基本特性，知道了一旦有一个线程访问某个对象的`synchronized`修饰的方法或者代码块时，该线程则获取这个对象的锁，其他线程不能再调用该对象被`synchronized`影响的任何方法。那么，如果这个线程自己调用该对象其他的`synchronized`方法，Java是如何判定的？

这就涉及到了Java中锁的重要特性：`可重入性`。

## 线程的安全和可重入性

### 线程安全

线程安全函数的概念比较直观，同一进程的不同线程会共享同一主内存，线程的私有栈中只包括PC，栈，操作数栈，局部变量数组和动态链接。对共享内存进行读写时，若要保证线程安全，则必须通过加锁的方式。

### 可重入

当某个线程请求进入由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”指的是获取对象锁的操作粒度是“线程”而非“调用”（pthread互斥体的获取操作是以“调用为粒度”）。重入的一种实现方法是为每个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法。当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1，此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次获取这个锁，那么计数器会递增，当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。

如果锁不是可重入的，那么下面代码将死锁，调用child的method方法，首先会获得父类内置锁，然后获得child的内置锁，然后调用父类方法时，需要再次获得父类内置锁，如果不是可重入，那么只有等待了...


```Java

public class Father
{
	public synchronized void method()
	{
		System.out.println("Father method called.");
		//TODO
	}
}
public class Child extends Father
{
	public synchronized void method()
	{
		System.out.println("Child method called.");
		super.method();
		//TODO
	}
}
```
