
# 位运算

> Create Time : 2016年12月30日

<!-- TOC -->

- [位运算](#%E4%BD%8D%E8%BF%90%E7%AE%97)
    - [Java位运算](#java%E4%BD%8D%E8%BF%90%E7%AE%97)
        - [表示方法](#%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95)
        - [位运算符](#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)
        - [位运算符的优先级](#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7)
    - [按位异或运算符 ^](#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6-%5E)
    - [Java中除了二进制的表示方法](#java%E4%B8%AD%E9%99%A4%E4%BA%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95)
        - [八进制数的表示方法](#%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95)
        - [十六进制数的表示方法](#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95)

<!-- /TOC -->

## Java位运算

### 表示方法

在Java中,二进制数使用补码表示,最高位为符号位,正数的符号位为0,负数为1.

补码的表示需要满足如下要求:
* 正数的最高位为0,其余各位代表数值本身(二进制数)
* 对于负数,通过对该数绝对值的补码按位取反,再对整个数加1.

### 位运算符

位运算表达式由操作数和位运算符组成,实现对整数类型的二进制数进行位运算.位运算符可以分为逻辑运算符(包括非`~`,与`&`,或`|`,和异或`^`)及意为运算符（包括`>>`,`<<`,`>>>`）。

* `<<` 左移位运算符，能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）
* `>>` "有符号"右移运算符，将运算符左侧的运算对象向右移动运算符右侧指定的位数。"有符号"右移运算符使用了"符号扩展"：若值为正，则在高位插入0，若值为负，则在高位插入1.
* `>>>` 无符号右移运算符,使用了"零扩展",无论正负,都在高位插入0.这一运算符在C或C++中是没有的.

如果对`char`,`byte`,或者`short`进行移位处理，那么在移位之前，它们会自动转换成为一个int，只有在右侧的5个低位才会用到。这样可防止我们在一个int数里不切实际的位数。若对一个`long`值进行处理，最后得到的结果也是`long`。此时只会用到右侧的6个低位,防止移动超过`long`值里现成的位数.但在进行"无符号"右移位时,也可能遇到一个问题。若对`byte`或`short`值进行右移位运算，得到的可能不是正确的结果（Java 1.0 和 Java 1.1 特别突出）。它们会自动转换成`int`类型，并进行右移位。但"零扩展"不会发生，所以在那些情况下会得到-1的结果。

在进行位运算时,需要注意以下几点:

* `>>>`和`>>`的区别是：在执行运算时，`>>>`运算符的操作数高位补0，而`>>`运算符的操作数高位移入原来高位的值。
* 右移一位相当于除以2，左移一位（在不溢出的情况下）相当于乘以2 。移位运算速度高于乘除运算。
* 若进行位逻辑运算的两个操作数的数据长度不相同,则返回值应该是数据长度较长的数据类型。
* 按位异或可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的值反转。
* 按位与运算可以用来屏蔽特定的位,也可以用来取某个整型数中某些特定的位。
* 按位或运算可以用来对某个整型数的特定位的值置1。

### 位运算符的优先级

`~`的优先级最高,其次`<<`、`>>`、`>>>`,其次`&`,其次`^`，最低的是`|`.

## 按位异或运算符 ^



## Java中除了二进制的表示方法


### 八进制数的表示方法

### 十六进制数的表示方法



