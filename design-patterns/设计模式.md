
# 设计模式总纲

> 摘录自Head First Design Patterns


## 不同阶段的开发人员如何看待设计模式

* `初学者` - 初学者到处使用模式。这很好，初学者可以借此培养许多使用模式的经验。初学者也认为“我使用越多的模式，我的设计就越好”。初学者将慢慢认识并非如此，所有的设计都应该尽量保持简单。只有在需要实践扩展的地方，才值得使用复杂性和模式。
* `中级` - 随着学习的进程，终极人员的心智开始能够分辨何时需要模式，而何时不需要。终极人员的心智依然会企图把过多的模式套用在不适当的地方，但他们也开始察觉到有些模式并不适合目前的情况，可以对其改编使其适合。
* `悟道者` - 悟道者的心智能够看到模式在何处能够自然融入。悟道者的心智并不急切于使用模式，而是致力与最能解决问题的简单方案。悟道者的心智会考虑对象的原则，以及它们之间的折衷。当对模式的需要自然出现时，悟道者的心智就拿捏得宜的采用模式。悟道者的心智也能看到相似模式之间的关系，以及他们在意图上微妙差异。悟道者的心智也同于初学者的心智--不会让这些模式的知识过度影响设计的决策。

为了实际需要的扩展使用模式，不要为了假想而使用模式。

简单才是王道。如果你不用模式就能够设计出更简单的实现方案，那就去干吧。

模式是工具，而不是规则，需要在适当的时候调整以适合你的设计。

## 基础

* 抽象
* 封装
* 多态
* 继承
* 组合
* 关联

## 设计原则

* 找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
* 针对接口编程，而不是针对实现编程（`针对接口编程`的意思是`针对超类型(superType)编程`）
* 组合优于继承（has a > is (like) a）
* 为了交互对象之间的松耦合关系设计而努力
* 类应该对扩展开放，对修改关闭。
* 需要依赖抽象，而不是依赖具体类。
* 最少知道原则，只和你的密友交谈。
* 别调用我们，我们会调用你。
* 一个类应该只有一个引起变化的原因。


## 设计模式

* `策略` - 定义了算法族，分别封装起来，让他们之间可以互相替换，此模式算法的变化独立于使用算法的客户。
* `观察者` - 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它所有的依赖者都会接收到通知并自动更新。
* `装饰者` - 动态的将责任附加到对象上。若要扩展功能，装饰者提供了比集成更有弹性的替代方案。
* `简单工厂` - **不是一个真正的模式**。但是和抽象工厂和工厂方法模式一样，它经常被用于封装创建对象的代码。
* `工厂方法` - 定义了一个创建对象的接口，但由子类决定实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
* `抽象工厂` - 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确制定具体类。
* `单例` - 确保一个类只有一个实例，并提供一个全局的访问点。
* `命令` - 将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
* `适配器` - 将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。
* `外观` - 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
* `模板方法`- 在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
* `迭代器` - 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
* `组合` - 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别的对象以及对象组合。
* `状态` - 允许对象在内部状态改变时改变它的行为，对象看起来好像是修改了它的类。
* `代理（远程）` - 就好比远程对象的本地代表。
* `代理（虚拟）` - 作为创建开销大的对象的代表。虚拟代理经常知道我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。
* `代理（保护）` - 为另一个对象提供一个替身或占位符以访问这个对象。    


