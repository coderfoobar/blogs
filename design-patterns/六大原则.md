
# 设计模式六大原则

> Create Time : 2017年3月18日 Ref : http://blog.csdn.net/zhengzhb/article/details/7278174/

## 单一职责原则
> https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99

> 在面向对象编程领域中，单一功能原则（`Single Responsibility Principle`）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有这个类的服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。

这个数据有罗伯特·C·马丁(Robert Cecil Martin)在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为<面向对象设计原则>的文章中给出。马丁表述该原则是基于《结构化分析和系统规格》一书中的内聚原则上。

马丁把功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同改变圆心的事物耦合在一起设计是糟糕的。

保持一个类专注于单一功能点的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，假使这两个功能存在于同一个类中的话，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作。


## 里氏代换原则
## 开闭原则

> Ref : https://quanke.gitbooks.io/design-pattern-java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html

开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则有Bertrand Meyer于1988年提出，其定义如下：

> 开闭原则（Open-Closed Principle，OCP）： 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

在开闭原则的定义中，软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。

任何软件都需要面临一个很重要的问题，即他们的需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时，我们应当尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无需修改现有代码，使的软件系统在拥有适应性和灵活性的同时，具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。

为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过他们定义系统的抽象层，再通过具体的类来进行扩展。如果需要修改系统的行为，无需对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。

示例：

Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图，和柱状图等，为了支持多种图标显示方式，原始设计方案如图1所示：

![ocp-crm-chart](./ocp-crm-chart.jpg)

在ChartDisplay类的display()方法中存在如下代码片段：

```
...
if (type.equles("pie")) {
    PieChart chart = new PieChart();
    chart.display();
} else if (type.equles("bar")) {
    BarChart chart = new BarChart();
    chart.dispaly();
}
...
```

在该代码中如果需要增加一个新的图标类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码增加新的判断逻辑，违反了开闭原则。

现在对系统进行重构，使之符合开闭原则。

在本实例中，由于ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无需修改源代码，满足开闭原则。

具体做法如下：

1. 增加一个抽象图标类AbstractChart，将各种具体图标类作为其子类；
2. ChartDisplay类针对抽象图表进行编程，由客户端来决定使用哪种具体图表。

重构后结构如下图所示：

![ocp-crm-chart-refactor](./ocp-crm-chart-refactor.jpg)

重构后，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表进行编程，并通过setChart方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图标。如果想要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无需修改现有类库的源代码。

---

Ref ：http://m.blog.csdn.net/article/details?id=50277639

## 依赖倒置原则
## 迪米特法则
## 接口隔离原则