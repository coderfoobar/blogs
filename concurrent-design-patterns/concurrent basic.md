
<!-- TOC -->

- [Concurrent Basic](#concurrent-basic)
    - [基础](#%E5%9F%BA%E7%A1%80)
        - [无处不在的线程](#%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E7%BA%BF%E7%A8%8B)
        - [线程的创建和运行](#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C)
        - [线程的状态和上下文切换](#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2)
        - [线程的监视](#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%91%E8%A7%86)
        - [原子性、内存可见性、指令重排序、synchronized、volatile](#%E5%8E%9F%E5%AD%90%E6%80%A7%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8Fsynchronizedvolatile)
        - [线程的优势和风险](#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E9%A3%8E%E9%99%A9)
        - [常用术语](#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD)

<!-- /TOC -->

# Concurrent Basic

> 本文引自《Java多线程编程实战指南（设计模式篇）》

## 基础

***

### 无处不在的线程

进程（Process）代表运行中的程序。一个运行的Java程序就是一个进程。

从操作系统地角度来看，线程（Thread）是进程中可独立执行的子任务。一个进程可以包含多个线程。同一个进程中的线程共享该进程所申请到的资源，入内存空间和文件句柄。

从JVM的角度来看，线程是进程中的一个组件（Component），它可以看作执行Java代码的最小单位。Java程序中任何一段代码总是执行在某个确定的线程中。

JVM在启动的时候会创建一个main线程，该线程负责执行Java程序的入口方法（main方法）。

在多线程编程中，弄清楚一段代码具体由哪个（或者哪种）线程去负责执行的这点很重要，这关系到性能问题，线程安全问题等。

Java中的线程可以分为守护线程（Deamon Thread）和用户线程（User Thread）。用户线程会阻止JVM的正常停止，即JVM正常停止前应用程序中的所有用户线程必须先停止完毕。否则JVM无法停止。而守护线程则不会影响JVM的正常停止，即应用程序中所有守护线程在运行也不影响JVM的正常停止。因此守护线程用来做一些重要性不是很高的任务，例如监视其他线程的运行情况。

***

### 线程的创建和运行

***

### 线程的状态和上下文切换

**`Thread.State :`**

* `NEW` - 新建状态。
* `RUNNABLE` - 该状态是一个复合状态。包括两个子状态：`READY`和`RUNNING`。
* `BLOCKED` - 一个线程发起一个阻塞式I/O（Blocking I/O）操作后，或者试图去获得一个由其他线程持有的锁时，相应的线程会处于该状态。处于该状态的线程不会占用CPU资源。当相应的I/O操作完成后，或者相应的锁被其他线程释放后，该线程的状态又可以转换为`RUNNABLE`。
* `WAITING` - 一个线程执行了某些方法之后就会处于这种无限等待其他线程执行特定操作的状态。这些方法包括Object.wait(),Thread.join()和LockSupport.park()。能够使相应的线程从`WAITING`状态转换为`RUNNABLE`状态的相应方法包括：Object.notify(),Object.notifyAll()和LockSupport.unpark(thread);
* `TIMED_WAITING` - 该状态可`WAITING`状态类似，差别在于处于该状态的线程并非无限等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为`RUNNABLE`状态。
* `TERMINATED` - 已经执行结束的线程处于该状态。由于一个线程实例只能被启动一次，因此一个线程也只可能有一次处于该状态。Thread实例的run方法正常返回或者由于抛出异常而提前终止都会导致相应的线程处于该状态。

 从上述描述可知，一个线程在其整个生命周期中，只可能一次处于`NEW`的状态和`TERMINATED`状态。而一个线程的状态从RUNNABLE状态转换为BLOCKED、WAITING和TIMED_WAITING这几个状态中的任何一个状态都意味着上下文切换（`Context Switch`）的产生。

 **`上下文切换 :`** 对线程上下文信息进行保存和恢复的过程就称之为`上下文切换`。

***

### 线程的监视

* `jvisualvm`
* `jstack`
* `Java Mission Control`

***

### 原子性、内存可见性、指令重排序、synchronized、volatile

* `原子操作` - Atomic，相应的操作时单一不可分割的操作。在多线程环境中，非原子操作可能会收到其他线程的干扰。

* `synchronized` - 可以实现操作的原子性。其本质时通过该关键字所包括的临界区（Critical Section）的排他性保证在任何一个时刻只有一个线程能够执行临界区内的代码,这使得临界区中的代码代表了一个原子操作。`synchronized`关键字代表的另外一个作用是内存的可见性（Memory Visibility），即保证了一个线程执行临界区代码时所修改的变量值对于稍后执行临界区中的代码的线程来说是可见的。

* `临界区` - Critical Section，示例代码如下：
```Java
synchronized(syncObject) { 
    //critical section
}
```

* `内存可见性` - Memory Visibility，CPU在执行代码的时候，为了减少变量访问的时间消耗可能将代码中访问的变量的值缓存道该CPU的缓存区（如`L1 Cache`，`L2 Cache`等）中。因此，相应代码再次访问某个变量时，相应的值可能时从CPU缓存区而不是主内存中读取的。同样的，代码对这些被缓存锅的变量的值的修改也可能仅是被写入CPU缓存区，而没有被写回主内存。由于每个CPU都有自己的缓存区，因此一个CPU混村去中的内容对于其他CPU而言是不可见的。这就导致了其他CPU上运行的其他线程可能无法“看到”该线程对某个变量值所做的更改。这就是所谓的内存可见性。

* `volatile` - 保证内存可见性，但是不保证操作的原子性。其另一个作用是禁止了`指令重排序`。

* `指令重排序` - 编译器和CPU为了提高指令的执行效率，可能会进行指令重排序操作。

> `synchronized`和`volatile`的区别：`synchronized`既能保证操作的原子性，又能保证内存的可见性。而`volatile`仅能保证内存可见性。但是前者会导致上下文切换，而后者不会。

***

### 线程的优势和风险

**`优势 :`**

* 提高系统的吞吐率（`Throughput`）
* 提高响应性（`Responsiveness`）
* 充分利用多核（Muticore）CPU资源
* 最小化对系统资源的占用
* 简化程序的结构

**`风险 :`**

* 线程安全问题
* 线程的生命特征问题
* 上下文切换
* 可靠性

***

### 常用术语


| 术语 | 释义 |
| :--- | --- |
| 任务 Task | 把线程比作公司员工的，那么任务就可以被看作员工所要完成的工作内容。任务与线程并非一一对应的，通常一个线程可以用来执行多个任务。任务是一个相对的概念。一个文件可以被看作是一个任务，一个文件中的多个记录可以被看作一个任务，多个文件也可以看作一个任务|
| 并发 Concurrent | 表示多个任务同一时间段内被执行，这些任务并不是顺序执行的，而往往是以交替的方式被执行 |
| 并行 Parallel | 表示多个任务在同一时刻被执行 |
| 客户端线程 Client Thread | 从面向对象编程的角度来看，一个类总是对外提供某些服务（这也是这个类存在的意义）。其它类是通过调用该类的响应方法来使用这些服务的。因此，一个类的方法的调用方代码就被称为该类的客户端代码。相应地，执行客户端代码的线程就被称为客户端线程。因此，客户端线程也是一个相对的概念，某个类的客户端线程随着执行该方法调用方代码的线程的变化而变化 |
| 工作者线程 Worker Thread | 工作者线程是相对于客户端线程而言的。它表示客户端线程之外的用于特定用途的其他线程 |
| 上下文切换 Context Switch | 对线程的上下文信息进行保存和恢复的过程就称为上下文切换|
| 显示锁 Explicit Lock | 在Java代码中可以使用和控制的锁，即不是编译器和CPU内部使用的锁。包括`synchronized`和`java.util.concurrent.locks.Lock`接口的所有实现类 |
| 线程安全 Thread Safe | 一段操纵共享数据的代码能够保证在同一时间内被多个线程执行而保持其正确性的，就被称为是线程安全的 |


———————————————————— ***结束*** ————————————————————










































































