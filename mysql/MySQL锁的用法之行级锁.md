
# MySQL锁的用法之行级锁

> Create Time : 2017年7月3日 Ref : http://www.linuxidc.com/Linux/2012-09/69759.htm

行级锁是MySQL中粒度最小的一种锁，他能大大减少数据库操作的冲突。但是粒度越小，实现的成本也越高。MYISAM引擎只支持表级锁，而INNODB引擎能够支持行级锁，下面的内容也是针对INNODB行级锁展开的。

INNODB的行级锁有共享锁（S LOCK）和排他锁（X LOCK）两种。共享锁允许事物读一行记录，不允许任何线程对该行记录进行修改。排他锁允许当前事物删除或更新一行记录，其他线程不能操作该记录。

## 共享锁

> 用法： `SELECT ... LOCK IN SHARE MODE;`

> 效果: MySQL会对查询结果集中每行都添加共享锁。

> 锁申请前提：当前没有线程对该结果集中的任何行使用排他锁，否则申请会阻塞。

> 操作限制：使用共享锁线程与不使用共享锁线程对锁定记录操作限制表:


| 线程	| 读取操作 | 写入操作 | 	共享锁申请 |	排他锁申请 |
| ------- | -------- | ------- | ------------- | --------- |
| 使用共享锁 | 	可读 |	可写/不可写（报错）|	可申请 |	可申请 |
| 不使用共享锁	| 可读	| 不可写（阻塞）	| 可申请	| 不可申请（阻塞） |

1. 使用共享锁线程可对其锁定记录进行读取，其他线程同样也可对锁定记录进行读取操作，并且这两个线程读取的数据都属于同一个版本。
2. 对于写入操作，使用共享锁的线程需要分情况讨论，当只有当前线程对指定记录使用共享锁时，线程是可对该记录进行写入操作（包括更新与删除），这是由于在写入操作前，线程向该记录申请了排他锁，然后才进行写入操作；当其他线程也对该记录使用共享锁时，则不可进行写入操作，系统会有报错提示。不对锁定记录使用共享锁的线程，当然是不可进行写入操作了，写入操作会阻塞。
3. 使用共享锁进程可再次对锁定记录申请共享锁，系统并不报错，但是操作本身并没有太大意义。其他线程同样也可以对锁定记录申请共享锁。
4. 使用共享锁进程可对其锁定记录申请排他锁；而其他进程是不可以对锁定记录申请排他锁，申请会阻塞。

## 排他锁

> 用法： `SELECT ... FOR UPDATE;`

> 效果： MySQL会对查询结果集中每行都添加排他锁，在事物操作中，任何对记录的更新与删除操作会自动加上排他锁。

> 锁申请前提：当前没有线程对该结果集中的任何行使用排他锁或共享锁，否则申请会阻塞。

>  操作限制：使用排他锁线程与不使用排他锁线程对锁定记录操作限制表 :

| 线程	| 读取操作 | 写入操作 | 	共享锁申请 |	排他锁申请 |
| ------- | -------- | ------- | ------------- | --------- |
| 使用排他锁 |	可读（新版本） |	可写 |	可申请 |	可申请 |
| 不使用排他锁 |	可读（旧版本）	| 不可写(阻塞)	| 不可申请(阻塞)	| 不可申请(阻塞) |

1. 使用排他锁线程可以对其锁定记录进行读取，读取的内容为当前事物的最新版本；而对于不使用排他锁的线程，同样是可以进行读取操作，这种特性是一致性非锁定读。即对于同一条记录，数据库记录多个版本，在事物内的更新操作会反映到新版本中，而旧版本会提供给其他线程进行读取操作。
2. 使用排他锁线程可对其锁定记录进行写入操作；对于不使用排他锁的线程，对锁定记录的写操作是不允许的，请求会阻塞。
3. 使用排他锁进程可对其锁定记录申请共享锁，但是申请共享锁之后，线程并不会释放原先的排他锁，因此该记录对外表现出排他锁的性质；其他线程是不可对已锁定记录申请共享锁，请求会阻塞。
4. 使用排他锁进程可对其锁定记录申请排他锁（实际上并没有任何意义）；而其他进程是不可对锁定记录申请排他锁，申请会阻塞。