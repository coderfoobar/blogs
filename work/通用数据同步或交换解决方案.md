

# 通用数据同步或交换解决方案

## 为什么需要数据同步？

数据本身不在平台端产生，需要从三方同步过来，然后在本地数据库落地存储。

## 数据同步的概念以及角色

数据同步涉及到的角色通常是两种： 己方和三方，即己方从三方同步数据并落库。 己方又可称为平台方，三方又称为业务方。为便于表述下文中统一称为平台和三方。

## 数据同步的维度

数据同步的维度的通常分为三种：三方维度，数据所属维度（通常是自然人，证件号+证件类型+证件姓名），三方唯一约束维度。

## 数据同步业务风险

在数据同步方案确定之前，至少需要确定三件事： 
1. 三方唯一约束， 可能数数据的单号，也可能是单号+业务类型。
2. 双方数据所属的维度，通常情况下是双方的用户，亦即自然人， 即证件号+证件类型+证件姓名。
3. 数据的状态枚举值的映射， 三方的数据状态枚举大部分情况下与平台的状态枚举是不一致的， 而平台的数据状态与平台前端用户可以执行的操作指令息息相关， 映射好正确的状态，才能保证用户在平台前端操作的正确性。

数据同步对接过程中可能会遇到以下几个风险点：
1. 使用哪一方制定的接口标准：究竟是平台制定接口标准，还是三方制定接口标准。使用平台指定的接口标准无疑可以极大的降低业务风险。可以想象一下，平台业务在发展壮大，对接的三方也越来越多，如果都是使用的三方接口标准，这个业务该如何维护呢？
2. 接口层面三方开放给平台的数据维度：整个三方维度，还是数据所属维度。这决定了平台需要使用哪种模式与三方进行数据交互，下文说到数据同步的拉取模式时会详细介绍。
3. 平台产品未确定产品方案前，不要开始技术对接（血泪教训）


## 数据同步模式


数据同步的模式通常有平台拉取、三方推送、推拉结合三种模式。

### 基于平台的拉取模式

基于平台拉取的模式，也就是平台主拉取三方数据。这种方式需要三方提供接口给平台调用，拉取三方整条业务数据，平台再根据三方唯一约束来确定插入和更新操作。
拉取接口设计时， 请求必须要包含以下字段： 三方平台编码，拉取类型，开始时间，结束时间，数据所属维度（通常是自然人， 证件号，证件类型，证件姓名），三方唯一约束 (单号，单据类型)
显然，在平台方， 三方平台编码 + 三方唯一约束才能构成平台方的唯一约束。

其请求报文 json 格式举例如下:

```json
{
    "vendorCode" : "V10001", //三方平台编码， 平台制定接口标准时，指的是平台为三方制定的编码。 三方制定接口标准时， 是三方为平台制定的编码。 平台拉取的数据结果依然需要
    "pullType" : "0", // 拉取类型， 枚举值： 0-三方维度，1-数据所属维度，2-三方唯一约束维度
    "beginTime" : "yyyyMMddHHmmss", // pullType = 0,1时，不能为空且三方应对 beginTime 至 endTime 的最大范围做限定，以防止平台误操作将三防系统拉死。pullType = 2 时允许为空
    "endTime" : "yyyyMMddHHmmss", // 同 beginTime
    "userInfo" : { // 数据所属维度
        "idCardNo" : "", // 证件号
        "idCardType" : "", // 证件类型， 枚举值， 接口标准制定方是平台时，三方需要对枚举值做映射
        "idCardName" : "" // 证件姓名
    },
    "uniqueKeyList" : [ // 三方唯一约束列表， 可以一次拉取多个三方唯一约束相关的数据
        { 
            "orderNo" : "", // 业务数据单号， 通常情况足以标识数据的唯一性
            "orderType" : "" // orderNo 不足以标识三方业务的唯一性时， 需要用 orderType 字段来区分。 
                              // 这个字段可以由平台方自己分配， 未必要出现在接口中， 一定要体现在平台的数据库中。
                              // 为了提升业务的可扩展性， 即便三方承诺 orderNo 足以标识唯一性，为了防止被三方坑，也建议加上 orderType 字段。
        }
    ]
}
```

响应报文 json 格式如下： （成功，失败等接口元信息不在下边的例子中展示）

```json
{
    "vendorCode" : "V10001",
    "dataList" : [
        {
            "uniqueKey" : {
                "orderNo" : "",  // 业务数据单号， 通常情况足以标识数据的唯一性
                "orderType" : "", // orderNo 不足以标识三方业务的唯一性时， 需要用 orderType 字段来区分。 
                              // 这个字段可以由平台方自己分配， 未必要出现在接口中， 一定要体现在平台的数据库中。
                              // 为了提升业务的可扩展性， 即便三方承诺orderNo足以标识唯一性，为了防止被三方坑，也建议加上 orderType 字段。
            },
            "userInfo" : {
                "idCardNo" : "", // 证件号
                "idCardType" : "", // 证件类型，枚举值， 接口标准制定方是平台时，三方需要对枚举值做映射
                "idCardName" : "" // 证件姓名
            },
            "status" : "", // 数据业务状态值，枚举值： 需要平台与三方沟通，做好状态映射。 平台的状态控制是为了更好的满足平台前端用户的操作逻辑而设计。
            "deleteFlag" : "", // 删除标识，枚举值
            // ... ...
            // 其他业务字段， 除非涉及到业务逻辑控制，否则一应应该传输汉字描述等用户能看懂的信息
            // 涉及到业务逻辑控制的字段， 双方应该沟通好，看其如何影响数据的状态流转，以及业务控制规则
            // ... ...
        }
    ]
}
```


如果三方愿意开放整个三方维度的数据，为了保证99.99%的情况下平台与三方数据的一致性， 平台方至少需要两个定时任务拉取三方维度的数据，其中一个高频短时段用于保证了数据同步的准实时性， 另外一个低频长时段用于保证三方数据新增或者更新甚至宕机的情况下不丢失。 
另外，两种较小的拉取维度可以非常方便的用于调试和修复与三方不一致的数据。考虑到三方数据量可能比较大，为了防止平台将三方系统拉挂，在平台开发人员与三方开发人员对接口时，可以建议三方开发对拉取数据的最大时间范围做下限制。比如如果以三方维度拉取数据时，结束时间减去开始时间不能大于1天；以数据所属维度拉取时，结束时间不能大于7天。最大时间范文可以具体问题具体分析；以三方唯一约束维度拉取时，因为一个三方唯一约束最多对应一条数据，可以允许开始时间结束时间为空。


如果三方仅愿意开放用户维度（数据所属维度）的数据，这意味着平台不能通过两种定时任务去拉取整个三方的数据。
这种情况下，一种技术方案是通过定时查询整个平台的用户，然后遍历按用户拉取数据，如果平台用户数据量比较小还好， 一旦用户达到上百万或千万级别，定时任务的频率必须设置的极低才能降低系统的负载，不影响线上业务的正常运行；同时， 对于用户而言， 这样的拉取方案延迟性相当高，几乎不可用。

三方仅开放用户维度数据的意图很明显：拉取数据必须由平台前端用户手工点击相应功能去触发，也只能采取拉取用户维度数据的模式。

对于某些高频使用的业务功能，业务入口可以常驻在app较为明显的九宫格位，对于低频使用的功能，用户在不知道自己有相关业务数据的情况下， 恐怕不会点击相关功能。
而用户手工触发拉取过来的数据，同样需要落库，然后，才能对平台的前端提供正确的分页接口以及数据排序功能。而且，如果平台对接了多家三方机构，这些三方都只开放了用户维度的数据， 则在用户触发相关功能时， 需要遍历这些三方机构，一一调用相关接口去拉取三方的数据。 
如果采用同步的方式， 操作无疑相当耗时；如果采取异步的操作， 因为异步数据拉取的延迟性， 用户在前几次触发相关功能时，可能看不到想要的数据， 用户体验也比较差。如果不能说服三方开放整个三方维度的数据， 还是建议采用在用户触发功能时，异步拉取的方式，
虽然有一定的延迟，不过相对于让用户等待，体验会更好一点。另外，在实际操作的过程中， 可以再首次上线后，单独调用一次循环遍历所有平台用户，然后拉取数据的操作， 并在拉取成功后，向用户PUSH消息通知。


### 基于三方推送的模式

基于三方推送的模式，也就是三方主动推送新增或者有字段变更的数据。这种方案便于三方控制推的时机，相对平台主动拉取的模式来说，更具实时性。
这种方式需要三方推送整条业务数据，平台根据三方唯一约束来确定插入和更新操作。显然，在三方仅愿意开放用户维度数据等情况下，三方并不知道在什么时候推送谁的数据到平台，所以这种模式不试用。



### 基于推拉结合的模式

基于推拉结合的模式，可以兼具以上两种方式的优点，这种模式拉为主，推为辅。在推送时，三方推送数据仅带有三方唯一约束即可， 平台再根据三方推送的三方唯一约束拉取三方整条业务数据过来。 
同时平台仍然需要拉取方案中所说的两种定时任务（高频短时、低频长时）。显然这种模式同样不适用于



## 数据同步的后端系统

平台方系统可以分为后端系统和前端系统。 后端系统又可以分为平台与三方的数据交换网关，后端业务系统，以及对接前端的移动服务网关，PC服务网关等。

### 后端业务系统设计方案

后端业务系统下接数据交换网关，上承移动服务，PC服务网关，在数据同步方案中处于至关重要的位置。

#### 后端业务系统的数据库设计方案

后端业务系统数据库可以将基础表拆分为两个维度：平台方数据表与三方数据表。

平台方数据表负责直接对接前端， 三方数据表负责直接存储三方的数据。

前文说过，平台产品未确定产品方案前，不要开始技术对接， 因为产品方案未定，前端的产品形态便定不了，进而平台方的数据表结构便定不了！！！ ！！！

平台方的数据表需要包含平台方自定义生成的单号，具有唯一性。另外需要有三方机构编码，单据来源，数据所属维度，平台方数据的状态，创建时间，更新时间，以及其他各种业务字段，视产品原型设计而定。
对接前端的平台方数据表结构应该打平的，二维的。

```sql
CREATE TABLE `pt_order` (
  `id` int(11) NOT NULL COMMENT '主键',
  `pt_order_no` varchar(255) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '平台单号',
  `vendor_code` varchar(255) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '三方机构编码',
  `order_source` tinyint(8) NOT NULL DEFAULT '0' COMMENT '数据来源 -- 接口类型来源',
  `id_card_no` varchar(32) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '证件号',
  `id_card_type` tinyint(8) NOT NULL DEFAULT '0' COMMENT '证件类型',
  `id_card_name` varchar(255) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '证件名',
  `pt_order_status` int(8) NOT NULL DEFAULT 0 COMMENT '平台方的数据状态， 其枚举值通常与前端用户操作指令息息相关。产品方案确定后，这个字段的枚举值也应该是确定的。另外，其中一个枚举值可以是INVALID或DELETED，用于对应三方数据表的delete_flag已删除状态',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_unique_order` (`pt_order_no`) USING BTREE,
  KEY `idx_id_card_no` (`id_card_no`) USING BTREE,
  KEY `idx_create_time` (`create_time`) USING BTREE,
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```
其中， pt_order_no 便是平台方的单号，具有唯一性。


三方数据表的表结构，在设计上，除了主键id，三方机构编码，唯一约束，数据所属维度，数据状态，删除标识，创建时间，更新时间，等字段外，还需要一个用于存储整条三方数据报文的字段。 如下：

```sql
CREATE TABLE `vendor_order` (
  `id` int(11) NOT NULL COMMENT '主键',
  `vendor_code` varchar(32) COLLATE utf8mb4_bin NOT NULL COMMENT '三方机构编码',
  `vendor_order_no` varchar(64) COLLATE utf8mb4_bin NOT NULL COMMENT '订单号',
  `vendor_order_type` tinyint(4) NOT NULL COMMENT '可由我方定义订单类型',
  `id_card_type` int(255) DEFAULT NULL COMMENT '证件类型',
  `id_card_no` varchar(18) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '证件号',
  `id_card_name` varchar(512) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '证件姓名',
  `pt_order_no` varchar(0) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '外键，对应平台订单号',
  `vendor_order_status` varchar(4) COLLATE utf8mb4_bin NOT NULL COMMENT '原始单号状态，多家三方机构的数据原始状态未必一致，最终需要映射到平台表数据状态，此处使用varchar存储比较合适',
  `delete_falg` tinyint(8) NOT NULL COMMENT '删除标志',
  `his_order_info` text COLLATE utf8mb4_bin COMMENT '三方订单原始数据报文， 可以使用json， xml等格式存储',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_unique_order` (`his_order_no`,`hos_code`,`his_order_type`) USING BTREE,
  KEY `idx_create_time` (`create_time`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
```

平台方的数据表与三方数据表的关联关系上应该是一对多的。比如 vendor_order.pt_order_no 便对应了 pt_order.pt_order_no 字段。
平台方数据表的其他各种业务字段，应该至少对应于产品前端需要展示的字段，然后由 vendor_order.his_order_info 打平而来。


#### 业务方案

后端业务系统应该避免因三方数据接口的不同对前端产品形态带来变化。
三方数据网关

### 移动端服务系统，PC端服务系统设计方案



